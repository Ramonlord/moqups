var geom = {

  point: function(x, y) {
    var pt = {};
    pt.x = x || 0;
    pt.y = y || 0;

    pt.matrixTransform = geom.matrixTransform;
    return pt;
  },

  matrixTransform: function(matrix) {
    return geom.point(
      matrix.a * this.x + matrix.c * this.y + matrix.e,
      matrix.b * this.x + matrix.d * this.y + matrix.f
    )
  },

  /**
   * Calculates the angle between two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} angle between a and b
   */
  angle: function(a, b) {
    return Math.atan2(a[1] - b[1], a[0] - b[0]);
  },

  getLineAngleDegrees: function(pt1, pt2) {
    return Math.atan2(pt1.y - pt2.y, pt1.x - pt2.x) * 180 / Math.PI;
  },

  toDegrees: function(rad) {
    return rad * 180 / Math.PI % 360;
  },

  toRadians: function(deg) {
    return deg * .017453292519943295; // (angle / 180) * Math.PI;
  },

  //TODO replace with gl-matrix
  distance: function(pt1, pt2) {
    return Math.sqrt(Math.pow(pt1.x - pt2.x, 2) + Math.pow(pt1.y - pt2.y, 2));
  },

  //TODO replace with gl-matrix
  createMatrix: function(doc) {
    return doc.createSVGMatrix();
  },

  //TODO replace with gl-matrix
  scaleMatrixAroundPoint: function(scaleX, scaleY, transformPt, m) {
    m = m.translate(-transformPt.x * (scaleX - 1), -transformPt.y * (scaleY - 1));
    m = m.scaleNonUniform(scaleX, scaleY);
    return m;
  },

  //TODO replace with gl-matrix?
  getMatrixScale: function(m) {
    return {
      x: Math.sqrt(m.a * m.a + m.b * m.b),
      y: Math.sqrt(m.c * m.c + m.d * m.d)
    };
  },
  getMatrixRotationDeg: function(m) {
    m = m.inverse();
    // Note: we're getting rid of -0's generated by Chrome on m.inverse()
    // Reference: https://github.com/Evercoder/new-engine/issues/945
    return geom.toDegrees(Math.atan2(m.c ? m.c : 0, m.a ? m.a : 0));
  },
  projectToBorder: function(coords, border, matrix, threshold) {
    var pt = [];
    pt[0] = geom.point(0,0).matrixTransform(matrix);
    pt[1] = geom.point(0,border.height).matrixTransform(matrix);
    pt[2] = geom.point(border.width,border.height).matrixTransform(matrix);
    pt[3] = geom.point(border.width,0).matrixTransform(matrix);
    var dist = threshold;
    var finalpt = null;
    for (var i = 0; i < pt.length; i++) {
      var line = {
        point1: pt[i],
        point2: pt[(i+1)%4]
      };
      if (geom.projectPointToLine(line,coords) && geom.distance(coords,geom.projectPointToLine(line,coords)) < dist) {
        dist = geom.distance(coords,geom.projectPointToLine(line,coords));
        finalpt = geom.projectPointToLine(line,coords);
      }
    }
    return finalpt;
  },
  projectPointToLine: function(line, point) {
    var a1, a2;
    a1 = Math.atan2(line.point2.y - line.point1.y,line.point2.x - line.point1.x);
    a2 = Math.atan2(point.y - line.point1.y, point.x - line.point1.x);
    var l = geom.distance(point,line.point1)*Math.cos(a2-a1);
    if (Math.abs(l) > geom.distance(line.point1,line.point2) || l < 0) return null;
    return geom.point(l*Math.cos(a1) + line.point1.x,l*Math.sin(a1) + line.point1.y);
  },
  roundPoint: function(p, radix) {
    return geom.point(geom.round(p.x, radix || 0), geom.round(p.y, radix || 0));
  },

  /**
   * Helper function to determine whether there is an intersection between the two polygons described
   * by the lists of vertices. Uses the Separating Axis Theorem
   *
   * @param a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
   * @param b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
   * @return true if there is any intersection between the 2 polygons, false otherwise
   */
  // http://stackoverflow.com/questions/10962379/how-to-check-intersection-between-2-rotated-rectangles
  doPolygonsIntersect: function(a, b) {
    var polygons = [a, b];
    var minA, maxA, projected, i, i1, j, minB, maxB;

    for (i = 0; i < polygons.length; i++) {

      // for each polygon, look at each edge of the polygon, and determine if it separates
      // the two shapes
      var polygon = polygons[i];
      for (i1 = 0; i1 < polygon.length; i1++) {

        // grab 2 vertices to create an edge
        var i2 = (i1 + 1) % polygon.length;
        var p1 = polygon[i1];
        var p2 = polygon[i2];

        // find the line perpendicular to this edge
        var normal = {
          x: p2.y - p1.y,
          y: p1.x - p2.x
        };

        minA = maxA = undefined;
        // for each vertex in the first shape, project it onto the line perpendicular to the edge
        // and keep track of the min and max of these values
        for (j = 0; j < a.length; j++) {
          projected = normal.x * a[j].x + normal.y * a[j].y;
          if (minA === undefined || projected < minA) {
            minA = projected;
          }
          if (maxA === undefined || projected > maxA) {
            maxA = projected;
          }
        }

        // for each vertex in the second shape, project it onto the line perpendicular to the edge
        // and keep track of the min and max of these values
        minB = maxB = undefined;
        for (j = 0; j < b.length; j++) {
          projected = normal.x * b[j].x + normal.y * b[j].y;
          if (minB === undefined || projected < minB) {
            minB = projected;
          }
          if (maxB === undefined || projected > maxB) {
            maxB = projected;
          }
        }

        // if there is no overlap between the projects, the edge we are looking at separates the two
        // polygons, and we know there is no overlap
        if (maxA < minB || maxB < minA) {
          return false;
        }
      }
    }
    return true;
  },

  withinThreshold: function(point, bound, threshold) {
    return (point >= bound - threshold && point <= bound + threshold);
  },


  //like withinThreshold but checks against two objects instead
  /*@deprecated*/
  withinThreshold2: function(point, point2, bound, threshold) {
    return (point >= bound - threshold && point <= bound + threshold) && (point2 >= bound - threshold && point2 <= bound + threshold);
  },

  /**
   * Get Angle between three points (Pythagoras theorem)
   * @param A
   * @param B
   * @param C
   * @returns {number}
   */
  findAngle: function(A, B, C) {
    var AB = Math.sqrt(Math.pow(B.x - A.x, 2) + Math.pow(B.y - A.y, 2));
    var BC = Math.sqrt(Math.pow(B.x - C.x, 2) + Math.pow(B.y - C.y, 2));
    var AC = Math.sqrt(Math.pow(C.x - A.x, 2) + Math.pow(C.y - A.y, 2));
    return Math.acos((BC * BC + AB * AB - AC * AC) / (2 * BC * AB));
  },

  isHorizontalOverlapping: function(boundsA, boundsB) {
    var x0 = Math.max(boundsA.x, boundsB.x);
    var x1 = Math.min(boundsA.x + boundsA.width, boundsB.x + boundsB.width);
    return x0 < x1;
  },

  isVerticalOverlapping: function(boundsA, boundsB) {
    var y0 = Math.max(boundsA.y, boundsB.y);
    var y1 = Math.min(boundsA.y + boundsA.height, boundsB.y + boundsB.height);
    return y0 < y1;
  },

  verticalOverlapCenter: function(boundsA, boundsB) {
    var y0 = Math.max(boundsA.y, boundsB.y);
    var y1 = Math.min(boundsA.y + boundsA.height, boundsB.y + boundsB.height);
    return (y0 + (y1 - y0) / 2);
  },

  horizontalOverlapCenter: function(boundsA, boundsB) {
    var x0 = Math.max(boundsA.x, boundsB.x);
    var x1 = Math.min(boundsA.x + boundsA.width, boundsB.x + boundsB.width);
    return (x0 + (x1 - x0) / 2);
  },

  horizontalDistance: function(boundsA, boundsB) {
    var startX = Math.max(boundsA.x, boundsB.x);
    var endX = Math.min(boundsA.x + boundsA.width, boundsB.x + boundsB.width);
    return Math.abs(endX - startX);
  },

  verticalDistance: function(boundsA, boundsB) {
    var startY = Math.max(boundsA.y, boundsB.y);
    var endY = Math.min(boundsA.y + boundsA.height, boundsB.y + boundsB.height);
    return Math.abs(endY - startY);
  },

  setTransform: function(el, transform) {
    el.setAttribute('transform', transform);
  },

  getTransform: function(el) {
    return el.getAttribute('transform') || '';
  },

  matrixToString: function(m) {
    return 'matrix(' + m.a + ' ' + m.b + ' ' + m.c + ' ' + m.d + ' ' + m.e + ' ' + m.f + ')';
  },

  matrixToCSSString: function(m) {
    return 'matrix(' + m.a + ', ' + m.b + ', ' + m.c + ', ' + m.d + ', ' + m.e + ', ' + m.f + ')';
  },

  parseMatrixFromSVGTransformString: function(str){
    return str ? str.replace(/^\s*matrix\(\s*/, '').replace(/\s*\)\s*$/, '').split(/\s+/).map(function(item) {
      return parseFloat(item);
    }) : null;
  },

  setMatrix: function(el, m) {
    el.setAttribute('transform', geom.matrixToString(m));
  },

  unscaleMatrix: function(m) {
    var s = geom.getMatrixScale(m)
    var scaleX = 1 / s.x;
    var scaleY = 1 / s.y;
    //	m = m.translate(-this.x * (scaleX - 1), -this.y * (scaleY - 1));
    m = m.scaleNonUniform(scaleX, scaleY);
    return m;
  },

  unmatrix: function(m) {
    var A = m.a;
    var B = m.b;
    var C = m.c;
    var D = m.d;
    var rad2deg = 180 / Math.PI;

    if (A * D == B * C) throw new Error('transform#unmatrix: matrix is singular');

    // step (3)
    var scaleX = Math.sqrt(A * A + B * B);
    A /= scaleX;
    B /= scaleX;

    // step (4)
    var skew = A * C + B * D;
    C -= A * skew;
    D -= B * skew;

    // step (5)
    var scaleY = Math.sqrt(C * C + D * D);
    C /= scaleY;
    D /= scaleY;
    skew /= scaleY;

    // step (6)
    if (A * D < B * C) { //handles flipped matrices
      A = -A;
      B = -B;
      skew = -skew;
      scaleX = -scaleX;
    }

    return {
      translate: [m.e, m.f],
      rotate: Math.atan2(B, A) * rad2deg,
      skew: Math.atan(skew) * rad2deg,
      scale: [scaleX, scaleY]
    }
  },

  //https://code.google.com/p/svgweb/issues/detail?id=434
  getTransformToElement: function(elementCTM, targetCTM) {
    return targetCTM.inverse().multiply(elementCTM);
  },

  //http://www.mathopenref.com/trigquadrantal.html
  isQuadrantalAngle: function(angle) {
    return !(angle % 90)
  },

  reflect: function(a, b) {
    var diff = a - b;
    return a + diff;
  },

  rectsIntersect: function(r1, r2) {
    return !(
      r2.left > r1.right || 
      r2.right < r1.left || 
      r2.top > r1.bottom ||
      r2.bottom < r1.top
    );
  },

  rectContainsRect: function(large_rect, small_rect) {
    return (
      large_rect.left <= small_rect.left &&
      large_rect.right >= small_rect.right &&
      large_rect.top <= small_rect.top &&
      large_rect.bottom >= small_rect.bottom
    );
  },

	/**
	 * Ported from here MoutJS http://moutjs.com/
	 * Round number to a specific radix
	 */
	round: function(value, radix){
	    radix = radix || 1; // default round 1
	    return Math.round(value / radix) * radix;
	},

    //http://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving
    modulo: function(a, b){
        return (a % b + b) % b
    }
};